#Einbinden der Pakete
```{r}
library(readr)
library(Metrics)
library(ggplot2)
library(dplyr)
library(e1071)

```
# Laden der Daten 
```{r}
umsatzdaten <- read_csv("https://raw.githubusercontent.com/christophson3/Data-science-Team-8/main/umsatzdaten.csv", 
    col_types = cols(X1 = col_skip()))

full_dataset <- read_csv("https://raw.githubusercontent.com/christophson3/Data-science-Team-8/main/full_dataset.csv", 
    col_types = cols(X1 = col_skip()))
```

```{r}

umsatzdaten$Warengruppe <- factor(umsatzdaten$Warengruppe)
full_dataset$Warengruppe <- factor(full_dataset$Warengruppe)
umsatzdaten$Wertung <- factor(umsatzdaten$Wertung)
full_dataset$Wertung <- factor(full_dataset$Wertung)
umsatzdaten$KielerWoche <- factor(umsatzdaten$KielerWoche)
full_dataset$KielerWoche <- factor(full_dataset$KielerWoche)

```

# Aufteilung des Datensatzes in Trainings- und Testdaten
```{r}
# Zufallszähler setzen (um die zufällige Partitionierung bei jedem Durchlauf gleich zu halten)
set.seed(1)

# Zufällige Ziehung von Indizes für die Zeilen des Datensatzes, die dem Traininsdatensatz zugeordnet werden
indices_train <- sample(seq_len(nrow(umsatzdaten)), size = floor(0.80 * nrow(umsatzdaten)))

# Definition des Trainings- und Testdatensatz durch Selektion bzw. Deselektion der entsprechenden Datenzeilen
train_dataset <- train_dataset_org <- umsatzdaten[indices_train, ]
test_dataset <- umsatzdaten[-indices_train, ]
test_dataset = rbind(train_dataset[1,],test_dataset)
test_dataset = test_dataset[-1,]

```

# Data Preparation
```{r}
# Uncomment the next line if you want to check the correctness of your following code for the svm estimation with a small (and computationally fast) part of the training data set
#train_dataset <- sample_frac(train_dataset_org, .10)
```

# Training the SVM


```{r}
# Estimation of various SVM (each with optimized weighting parameters) using systematically varied hyper parameters (typically called 'grid search' approach) and cross validation
# the resulting object includes the optimal model in the element named 'best.model'
svm_tune <- tune(svm, Umsatz ~ Vortagsumsatz + Temperatur + as.factor(Warengruppe) + as.factor(Wertung) + Umsatz_Vorwoche + Wettercode + Bewoelkung + Windgeschwindigkeit + as.factor(KielerWoche), data=train_dataset, ranges = list(epsilon = seq(0.2,1,0.1), cost = 2^(1:3)))
```
## Checking the Prediction Quality


SVM with cross validation and grid Search
```{r}
# Calculating the prediction for the training data using the best model according to the grid search

pred_train <- predict(svm_tune$best.model, train_dataset)
# Calculating the prediction quality for the training data using the MAPE
mape(train_dataset$Umsatz, pred_train)
```

### Test Data

SVM with cross validation and grid Search
```{r}
# Calculating the prediction for the test data using the best model according to the grid search
pred_test <- predict(svm_tune$best.model, test_dataset)
# Calculating the prediction quality for the test data using the MAPE
mape(test_dataset$Umsatz, pred_test)
```

### Vorhersage für den 05 Juni 2019

```{r}
# zusammenstellen des Datensatzes
newdata <- (filter(full_dataset, Datum == "2019-06-05"))
newdata['Wochentag'] <- "Mittwoch"
newdata <-rbind(newdata, newdata[rep(1, 6), ])

data <- filter(umsatzdaten, Datum == "2019-06-04")
data2 <-filter(umsatzdaten,Datum == "2019-05-28")

#Schleife um die Daten zusammenzu stellen
for (i in (1:6)) {
  
  newdata$Warengruppe[[i]] <- i
  newdata$Vortagsumsatz[[i]] <- data$Umsatz[i]
  newdata$Umsatz_Vorwoche[[i]] <- data2$Umsatz[i]
}
newdata$Vortagsumsatz[[6]] <- 0
newdata$Umsatz_Vorwoche[[6]]<- 0
ModelVars = which(names(newdata) %in% 
    c("Vortagsumsatz" ,"Temperatur" , "Warengruppe" , "Wertung" , "Wettercode" , "Bewoelkung" , "Windgeschwindigkeit" , "KielerWoche", "Umsatz_Vorwoche", "Wochentag"))

newdata <- rbind(newdata[1,],data)
newdata <- newdata[-1,]

test2  = newdata[, ModelVars]

pred <- predict(svm_tune$best.model, test2)

show(pred)
```

### MAPE je Warengruppe
```{r}
listofmape <- vector(mode = "list", 6)
for (i in (1:6)){
  pred_test <- predict(svm_tune$best.model, filter(test_dataset, Warengruppe == i))
  lala <- filter(test_dataset,Warengruppe == i)
  listofmape[i] <- mape (lala$Umsatz, pred_test)
  cat(paste0("\n MAPE der Warengruppe ", i))
  cat(paste0(": \n ",format(mape (lala$Umsatz, pred_test)*100, digits=3, nsmall=2)))
}

```
